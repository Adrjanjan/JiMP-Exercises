namespace geometry {

    class Point {
    public:
        Point();

        Point(double x, double y);

        ~Point();

        void ToString(std::ostream *out) const;

        double Distance(const Point &other) const;

        double GetX() const;

        double GetY() const;

        Point &SetX(double x);

        Point &SetY(double y);

    private:
        double x_, y_;
    };

    class Square {
    public:
        Square();

        Square(const Point &_a, const Point &_b, const Point &_c, const Point &_d);

        double Area();

        double Circumference();

        void SetPoints(const Point &_a, const Point &_b, const Point &_c, const Point &_d);

        void SetPoints(const std::array<Point, 4> &pts);

        std::array<Point, 4> GetPoints();

        ~Square();

    protected:
    private:
        std::array<Point, 4> vertexes_;
    };
}


namespace geometry {
    using ::std::ostream;
    using ::std::endl;
    using ::std::pow;
    using ::std::sqrt;
    using ::std::cout;

    Square::Square() = default;

    Square::Square(const Point &_a, const Point &_b, const Point &_c, const Point &_d) {
        vertexes_[0] = _a;
        vertexes_[1] = _b;
        vertexes_[2] = _c;
        vertexes_[3] = _d;
    }

    double Square::Area() {
        return pow(vertexes_[0].Distance(vertexes_[1]), 2);
    }

    double Square::Circumference() {
        return 4 * vertexes_[0].Distance(vertexes_[1]);
    }

    void Square::SetPoints(const Point &_a, const Point &_b, const Point &_c, const Point &_d) {
        vertexes_[0] = _a;
        vertexes_[1] = _b;
        vertexes_[2] = _c;
        vertexes_[3] = _d;
    }

    void Square::SetPoints(const std::array<Point, 4> &pts) {
        vertexes_ = pts;
    }

    std::array<Point, 4> Square::GetPoints() {
        return vertexes_;
    }

    Square::~Square() = default;

    Point::Point() : x_(0), y_(0) {
        cout << "Konstruktor bezparametrowy" << endl;
    }

    Point::Point(double x, double y) {
        cout << "Konstruktor parametrowy" << endl;
        x_ = x;
        y_ = y;
    }

    Point::~Point() {
        cout << "Destruktor! Nic nie robie, bo nie musze zwalniać pamięci! " << x_ << " , " << y_;
        cout << endl;
    }

    double Point::Distance(const Point &other) const {
        return sqrt(pow(GetX() - other.GetX(), 2) + pow(GetY() - other.GetY(), 2));
    }

    void Point::ToString(ostream *out) const {
        (*out) << "(" << GetX() << ";" << GetY() << ")";
    }

    double Point::GetX() const {
        return this->x_;
    }

    double Point::GetY() const {
        return this->y_;
    }

    Point &Point::SetX(double x) {
        this->x_ = x;
        return *this;
    }

    Point &Point::SetY(double y) {
        this->y_ = y;
        return *this;
    }

    double Distance(const Point &a, const Point &b){
        return sqrt( pow(a.GetX() - b.GetX(),2) + pow(a.GetY() - b.GetY(),2));
    }
}




#include <memory>
#include <vector>
#include <iostream>
#include <sstream>
#include "Point.h"

using namespace std;

int main(){
//wywołuje konstruktor domyślny
    Point p2;
    Point p3 {}; //brace initilizer preferowany
//wywołuje konstruktor parametryczny
    Point p4 (12,34);
    Point p5 {30, 20};

    const Point *ptr_p = new Point(3,4);

    p2.ToString(&cout);

    p2.SetX(5).SetY(4);

    p2.ToString(&cout);

    cout <<  ptr_p->Distance(p2) << endl;

    delete ptr_p;

//parametry przekazywane do make_unique tworzące
//wskaznik unique_ptr przyjmują argumety konstruktora parametrycznego
//stąd możliwe są dwa wywowłania:
    auto ptr_p2 = make_unique<Point>();
    auto ptr_p3 = make_unique<Point>(-15,90);

    stringstream ss;
    ptr_p2->ToString(&ss);
    ss << " i ";
    ptr_p3->ToString(&ss);
    cout << "Odległość między punktami " << ss.str() << " wynosi " << ptr_p2->Distance(*ptr_p3) << endl;
    cout << "Zostanie wywołany destruktor punktów ptr_p2 i ptr_p3?" << endl;


    //ronica miedzy emplace_back a push_back:
    vector<Point> vp;
    //push_back kopiuje przekazany punkt na koniec wektora
    vp.push_back(Point {9,8});
    //natomiast emplace_back tworzy obiekt na koncu wektora
    //argumenty przekazane do funkcji odpowiadają konstruktorowi parametrycznemu
    vp.emplace_back(5, -5);
    //wiec mozna tez wywołać:
    vp.emplace_back();
}